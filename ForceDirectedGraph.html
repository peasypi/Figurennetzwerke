<!DOCTYPE html>
<meta charset="utf-8">
<style>

  body {
    background-color: #58ACFA
  }

  svg {
    background-color: #FFFFFF
  }
  .links line {
    stroke: #999;
    stroke-opacity: 0.6;
  }

  .nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
  }

</style>
<svg width="600" height="600"></svg>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script>
  //create somewhere to put the force directed graph
var svg = d3.select("svg"),
  width = +svg.attr("width"),
  height = +svg.attr("height");

//d3 code goes here
var nodes_data =  [
    {'name': 'mariechen', 'sex': 'FEMALE'},
    {'name': 'pauline', 'sex': 'MALE'},
    {'name': 'frau_weidenhammer', 'sex': 'FEMALE'},
    {'name': 'rese', 'sex': 'FEMALE'},
    {'name': 'meister_oelze', 'sex': 'MALE'},
    {'name': 'emil', 'sex': 'MALE'},
    {'name': 'frau_kramer', 'sex': 'FEMALE'},
    {'name': 'patschke', 'sex': 'MALE'}
    ]

//set up the simulation
//nodes only for now

var simulation = d3.forceSimulation()
            .nodes(nodes_data);
//add forces
//we're going to add a charge to each node
//also going to add a centering force -- feed in the x and y coordinates of the centre of the svg element as function parameters 
simulation.force("charge_force", d3.forceManyBody())
          .force("center_force", d3.forceCenter(width/2, height/2));

//draw circles for the nodes
var node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes_data)
            .enter()
            .append("circle")
            .attr("r", 10)
            .attr("fill", circleColour); 

node.append("text")
    .attr("x", 12)
    .attr("dy", ".35em")
    .text(function(d) { return d.name; });

//Function to choose what color circle will have
//Let's return blue for males and red for females
function circleColour(d) {
  if(d.sex == "FEMALE"){
    return "blue";
  } else {
    return "pink";
  }
}

    
function tickActions() {
  //update circle positions to reflect node updates on each tick of the simulation node
    node
      .attr("cx", function(d){ return d.x; })
      .attr("cy", function(d){ return d.y; })

    //update linke positions 
    //simply tells one end of the line to follow one node around
    //and the other end of the line to follow the other node around
    link
      //.attr("d", linkArc)
      /*.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });*/

  
       .attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
       /* return "M" + 
            d.source.x + "," + 
            d.source.y + "A" + 
            dr + "," + dr + " 0 0,1 " + 
            d.target.x + "," + 
            d.target.y; */
        
        const conincidentLines = false;
        if (conincidentLines) {
          return "M" + 
            d.source.x + "," + 
            d.source.y + "L" + 
            d.target.x + "," + 
            d.target.y;
        }
        else {
          delta = calcTranslationExact(4, d.source, d.target);
          var rightwardSign = d.target.x > d.source.x ? 1 : -1;
          return "M" + 
              (d.source.x + rightwardSign * delta.dx) + "," + 
              (d.source.y + (-rightwardSign * delta.dy)) + "L" + 
              (d.target.x + rightwardSign * delta.dx) + "," + 
              (d.target.y + (-rightwardSign * delta.dy));
        }
    });
   

}

simulation.on("tick", tickActions ); 

//Relationships
//type: A for Ally, E for Enemy
var links_data = [
  {'source': 'mariechen', 'target': 'pauline', 'weight': 0.04411538461538459},
  {'source': 'mariechen', 'target': 'emil', 'weight': -0.14888},
  {'source': 'pauline', 'target': 'mariechen', 'weight': 0.10401666666666665},
  {'source': 'pauline', 'target': 'frau_weidenhammer', 'weight': -0.0063937662337662385},
  {'source': 'pauline', 'target': 'rese', 'weight': -0.0010144444444444547},
  {'source': 'pauline', 'target': 'meister_oelze', 'weight': 0.0695489797008547},
  {'source': 'pauline', 'target': 'emil', 'weight': -0.3494},
  {'source': 'frau_weidenhammer', 'target': 'pauline', 'weight': 0.03416388888888889},
  {'source': 'frau_weidenhammer', 'target': 'rese', 'weight': -0.03995333333333333},
  {'source': 'rese', 'target': 'pauline', 'weight': -0.03952957908163266},
  {'source': 'rese', 'target': 'frau_weidenhammer', 'weight': -0.0016214285714285734},
  {'source': 'rese', 'target': 'meister_oelze', 'weight': 0.10968933333333333},
  {'source': 'rese', 'target': 'emil', 'weight': 0.0772478021978022},
  {'source': 'rese', 'target': 'patschke', 'weight': 0.08929999999999999},
  {'source': 'meister_oelze', 'target': 'pauline', 'weight': -0.042466965811965796},
  {'source': 'meister_oelze', 'target': 'rese', 'weight': 0.1250824074074074},
  {'source': 'meister_oelze', 'target': 'emil', 'weight': -0.08648},
  {'source': 'emil', 'target': 'mariechen', 'weight': -0.03814285714285716},
  {'source': 'emil', 'target': 'pauline', 'weight': 0.05132000000000001},
  {'source': 'emil', 'target': 'rese', 'weight': -0.059740000000000015},
  {'source': 'emil', 'target': 'meister_oelze', 'weight': 0.17669666666666667},
  {'source': 'patschke', 'target': 'rese', 'weight': -0.17644999999999997}
  ]

var link_force = d3.forceLink(links_data)
    .id(function(d) {return d.name; })
    .distance(200)

simulation.force("links", link_force)
          


//draw lines for the links
var link = svg.append("g")
      .attr("class", "links")
    .selectAll("path")
    .data(links_data)
    .enter().append("path")
      .attr("stroke-width", 1)
      .style("stroke", linkColour)
      .attr("marker-end", "url(#end)");

//Function to choose the line colour and thickness
//If the link type is "A" return green
//If the link type is "E" return red
function linkColour(d){
  console.log(d);
  if(d.weight > 0){
    return "green";
  } else {
    return "red";
  }
}

// build the arrow.
svg.append("svg:defs").selectAll("marker")
    .data(link.target)      // Different link/path types can be defined here
  .enter().append("svg:marker")    // This section adds in the arrows
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

function calcTranslationExact(targetDistance, point0, point1) {
    var x1_x0 = point1.x - point0.x,
        y1_y0 = point1.y - point0.y,
        x2_x0, y2_y0;
    if (y1_y0 === 0) {
        x2_x0 = 0;
        y2_y0 = targetDistance;
    } else {
        let angle = Math.atan((x1_x0) / (y1_y0));
        x2_x0 = -targetDistance * Math.cos(angle);
        y2_y0 = targetDistance * Math.sin(angle);
    }
    return {
        dx: x2_x0,
        dy: y2_y0
    };
}
  
var drag_handler = d3.drag()
    .on("start", drag_start)
    .on("drag", drag_drag)
    .on("end", drag_end);
 
function drag_start(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}
 
function drag_drag(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}
 
function drag_end(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

drag_handler(node)

</script>

